# 내용

- 일시 중단 함수의 개요
- 일시 중단 함수를 사용하는 방법
- 일시 중단 함수 대신 비동기 함수를 사용하는 경우
- 코루틴 컨텍스트
- 디스패치, 예외 처리기 및 취소 불가와 같은 다양한 유형의 컨택스트
- 코루틴 동작을 정의하기 위한 컨택스트의 결합 및 분리

# 일시 중단 함수

- 일시 중단 함수를 만들려면 시그니처에 suspend 제어자만 추가하면 된다. 일시 중단 함수는 delay()와 같은 다른 일시 중단 함수를 직접 호출할 수 있다.
- 코루틴 외부에서 일시 중단 함수를 호출하면 동작하지 않는다. 비 일시 중단 코드에서 함수를 호출하려면 코루틴 빌더로 감싸야 한다.
- 일시 중단 함수를 사용하지 않고 비동기 함수로만 레파지토리를 작성하는 경우에 Deferred를 사용해야하고 await 호출을 피할 수 없다. → 더러워짐..
- 일시 중단 함수(suspend)를 사용하면 deferred 의존 없이 레포지토리를 구성할 수 있다.
- 유연해지고(deferred 의존 x ), 간단해짐(async 이름 필요 없음, await 호출 x)

## 일시 중단 함수를 사용하는 경우

- 일반적으로 구현에 job이 엮이는 것을 피하기 위해서는 일시 중단 함수를 사용하는 것이 좋음
- 인터페이스에 비동기 함수를 사용하면 job을 반환하기 위한 구현을 해야한다.
- 비동기 함수는 private 및 internal 함수로 제한돼야 한다.
- 비동기 함수를 사용하는 코드를 적은 범위로 제한하는 것이 job을 더 이상 사용할 수 없을 때 리팩토리의 영향을 줄일 수 있다.

# 코루틴 컨텍스트

- 코루틴은 항상 컨택스트 안에서 실행된다.
- 컨택스트는 코루틴이 어떻게 실행되고 동작해야 하는지를 정의할 수 있게 해주는 요소들의 그룹이다.

## 디스패처

- 디스패처는 코루틴이 실행될 스레드를 결정하는데, 여기에는 시작될 곳과 중단 후 재개될 곳을 모두 포함한다.

### common pool

- cpu 바운드 작업을 위해서 프레임워크에 의해 자동으로 생성되는 스레드 풀.
- 기본 디스패처로 사용되지만 용도를 명시하고 싶다면 다른 디스패처처럼 사용할 수 있다.

### Unconfined

- 첫 번째 중단 지점에 도달할 때까지 현재 스레드에 있는 코루틴을 실행한다. 코루틴은 일시 중지된 후에, 일시 중단 연산에서 사용된 기존 스레드에서 다시 시작한다.

### 단일 스레드 컨택스트

- 항상 코루틴이 특정 스레드 안에서 실행된다는 것을 보장한다. 이 유형의 디스패처를 생성하려면 newSingleThreadContext()를 사용해야 한다.

### 스레드 풀

- 스레드 풀을 갖고 있으면 해당 풀에서 가용한 스레드에서 코루틴을 시작하고 재개한다.

## 예외 처리

- 코루틴 컨택스트의 또 다른 중요한 용도는 예측이 어려운 예외에 대한 동작을 정의하는 것이다. (CoroutineExceptionHandler를 통하여 구현할 수 있다.)

### non-cancellable

- 취소 중인 코루틴은 일시 중단될 수 없도록 설계됐기 때문에 취소 도중에 정지할 수 없다.
- 해당 경우가 필요할 때 NonCancellable 컨택스트를 사용하여 해결할 수 있다.

## 컨택스트에 대한 추가 정보

### 컨택스트 조합 및 분리

- 특정 스레드에서 실행하는 코루틴을 실행하고 동시에 해당 스레드를 위한 예외처리를 설정한다고 가정하는 경우에 이를 위해 더하기 연산자를 사용해 둘을 결합할 수 있다.
- 컨택스트에서 컨택스트 요소를 제거할 수 있다. 제거할 요소의 키에 대한 참조가 있어야 한다.

### withContext를 사용하는 임시 컨택스트 스위치

- 이미 일시 중단 함수 상태에 있을 때 withContext를 사용해 코드 블록에 대한 컨택스트를 변경할 수 있다.