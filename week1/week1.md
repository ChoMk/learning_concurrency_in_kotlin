# 1장
# 프로세스

- 이 책에서는 단일 프로세스만 고려한다.

# 스레드

- 사용성을 위하여 GUI관련 스레드는 블록하지 말자
- 프레임워크에서 스레드관리를 알아서 수행, 우리는 가져다가 사용만..

# 코루틴

- 같은 스레드에 10개의 코루틴이 있다면 해당 시점에는 하나의 코루틴만 샐행된다.
- 스레드와 코루틴의 가장 큰 차이점은 코루틴이 빠르고 적은 비용으로 생성할 수 있다는 것이다.
- 코틀린은 고정된 크기의 스레드 풀을 사용하고 코루틴을 스레드들에 배포하기 때문에 실행 시간이 매우 적게 증가한다.
- 코루틴이 일시 중단되는 동안 실행 중인 스레드는 다른 코루틴을 실행하는 데 사용되며 코루틴은 시작 또는 재개될 준비 상태가 된다
- 코루틴의 일부를 특정 스레드에서 실행하고, 실행을 중지한 다음 나중에 다른 스레드에서 계속 실행하는 것이 가능하다.

# 동시성

- 코드의 준독립적인 부분이 완성되는 순서에 관계없이 결과가 결정적이어야 함을 보장해야 한다.

# 병렬성

- 두 스레드가 정확히 같은 시점에 실행될 때만 발생한다.

# 정리

- 동시성은 두 개 이상의 알고리즘의 실행 시간이 겹쳐질 때 발생한다. 중첩이 발생하려면 두 개 이상의 실행 스레드가 필요하다. 이런 스레드들이 단일 코어에서 실행되면 병렬이 아니라 동시에 실행되는데 단일 코어가 서로 다른 스레드의 인스트럭션을 교차 배치해서 스레드들의 실행을 효율적으로 겹쳐서 실행한다. (병렬은 2개 이상의 코어와 2개 이상의 스레드가 있어야 각 코어가 동시에 스레드의 인스트럭션을 실행할 수 있다.)

# CPU 바운드 알고리즘에서의 동시성과 병렬성

- 단일코어에서 실행된다면 하나의 코어가 3개의 스레드 사이에서 문맥교환이 이루어지고 이에따라서 오버해드가 증가한다. 그로인하여 더 오래 걸릴 수 있다.

# IO 바운드 알고리즘에서의 동시성 대 병렬성

- IO 바운드 알고리즘은 끊임없이 무언가를 기다린다. 지속적인 대기는 단일 코어 기기에서 대기하는 중에 다른 유용한 작업에 프로세스를 사용할 수 있도록 한다. 따라서 IO 바운드인 동시성 알고리즘은 병렬이거나 단일 코어 상관없이 유사하게 수행될 것이다.
- 동시성 구현에서 항상 더 나은 성능을 발휘할 것으로 예상돼 IO 작업은 늘 동시성으로 실행하는 편이 좋다.

# 경한조건

- 코드를 동시성으로 작성했지만 순처적 코드처럼 동작할 것이라고 예상할 때 발생한다.(원자성이 포함되는 듯)

# 원자성 위반

- 다른 스레드에서 수정중인 내용은 또 다른 스레드에서 수정

# 데드락

- 아예 멈춤

# 라이브락

- 길막 이야기

# 넌 블록킹

- 대기하는 스레드가 해당 코드를 중지하고 다른일을 이어서 진행

# 2장

### CallFromWrongThreadException

- 안드로이드는 뷰 계층을 생성하지 않은 스레드가 관련 뷰를 업데이트하려고 할 때마다 위 에러 발생

### NetworkOnMainThreadException

- ui 스레드가 블로킹된다는 것은 애니메이션이나 기타 상호작용을 포함한 모든 ui 스레드가 블로킹된다는 것은 애니메이션이나 기타 상호작용을 포함한 모든 ui가 멈춘다는 것을 의미하므로 ui 스레드에서 네트워크 작업을 수행할 때마다 안드로이드는 중단된다.

### CoroutineDispatcher

- 기본적으로 가용성 부하 설정을 기반으로 스레드 간에 코루틴을 분산하는 오케스트레이터다.

## 코루틴을 시작하는 2가지 방법

# async 코루틴 시작

- 결과 처리를 위한 목적으로 코루틴을 시작했다면 async 사용하자.
- 취소 불가능한 넌블로킹 퓨처를 의미하며 T는 결과의 유형을 나타낸다.
- 결과처리하는 것을 잊어서는 안된다.

## join, await 차이

- join은 예외를 전파하지 않고 처리하는 반면, await는 단지 호출하는 것만으로 예외가 전파된다는 점이다.

# launch 코루틴 시작

- 결과를 반환하지 않는 코루틴을 시작하려면 launch를 사용해야 한다.
- 실패한 경우에만 통보 받기를 원하는 파이어 앤 포켓 시나리오를 위해 설계됐으며, 필요할 때 취소할 수 있는 함수도 함께 제공된다.

### 코루틴을 시작할 때 특정 디스패처 사용하기

- defaultDispatcher에서 실행됨을 알 수 있다.
- CorutineDispatcher를 생성하기 위해 main을 변경하고 그 디스패처를 launch로 전달하면 지정된 스레드에서 코루틴이 실행됨을 알 수 있다.

# 다양하게 코루틴 함수 만들기

- 코루틴으로 감싼 동기 함수 : 명시적이지만 장황하고 번거로워진다.
- 특정 디스패처를 갖는 비동기 함수 : 내용이 덜 장황해지는 반면에 함수를 호출하는 호출자가 어떤 디스패처를 사용해야 할지 결정할 수 없어서 유연성이 떨어진다.
- 유연한 디스패처를 갖는 비동기 함수 : 함수를 호출하는 호출자가 어디서든 코루틴을 실행할 수 있지만 여전히 함수에 적절한 이름을 부여하는 것은 개발자의 몫

## 같은 프로젝트에서 이러한 방법들을 과하게 혼용하지 않는것이 좋다..