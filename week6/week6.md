# 원자성 위반

- 정확한 동기화 없이 객체의 상태를 동시에 수정할 때 발생한다.

# 스레드 한정

- 스레드 한정은 공유 상태에 접근하는 모든 쿠루틴을 단일 스레드에서 실행하도록 한정하는 것을 의미한다.상태가 더 이상 스레드 간에 공유되지 않으며 하나의 스레드만 상태를 수정한다는 뜻이다.

# 액터

스레드 한정은 앞에서 언급한 시나리오에서는 잘 작동하지만 앱의 여러 다른 부분에서 공유 상태를 수정해야 하거나. 원자 블록에서 더 높은 유연성을 원하는 시나리오의 경우 이를 확장하는 방법이 필요하다. 좀 더 복잡한 사나리오라면 스레드 한정이라는 개념 기반으로 이전에 보았던 동시성 기본 요소인 채널을 사용해 솔루션을 개선할 수 있다.

## 버퍼드 액터

- 액터는 다른 송신 채널과 동일하게 버퍼링될 수 있다.

### CoroutineContext를 갖는 액터

- 액터를 생성할 때 coroutineContext를 전달할 수 있다.

## coroutineStart

- 기본적으로 액터는 생성되는 즉시 시작된다. coroutineStart를 전달해 필요에 따라 동작을 변경할 수 있다.

# 상호 배제

- 지금까지 코드 블록의 모든 메모리 액세스가 단일 스레드에서 발생하도록 보장함으로써 원자성 위반을 회피했다. 두 개의 코드 블록이 동시에 실행되는 것을 피할 수 있는 또 다른 방법이 있다. → 상호 배제

## 상호배제의 이해

- 상호 배제란 한 번에 하나의 코루틴만 코드 블록을 실행할 수 있도록 하는 동기화 메커니즘을 말한다.

## 뮤텍스 생성

- Mutext를 이용하여 인스턴스를 만들 수 있다. 뮤텍스가 있으면 람다를 실행하는 일시 중단 확장 함수 withLock을 사용할 수 있다.

한 번에 하나의 코루틴만 잠금을 보유하고, 잠금을 시도하는 다른 코루틴을 일시 중단함으로써 카운터에 대한 모든 증분이 동기화 되도록 한다. 따라서 다음과 같이 몇 번을 호출하더라도 counter의 중분 중 어느 것도 유실되지 않는다.

→ 잠금 및 잠금 해제에 대한 상세한 제어가 필요하면 일시 중단 함수 lock 및 일반 함수 unlock을 사용할 수 있다.

## 휘발성 변수

- 휘발성 변수는 구현하려는 스레드 안전 카운터와 같은 문제를 해결하지 못한다. 그러나 휘발성 일부 시나리오에서 스레드 간에 정보를 공유해야할 때 간단한 솔루션으로 사용될 수 있다.

## 스레드 캐시

- JVM에서 각 스레드는 비휘발성 변수의 캐시된 사본을 가질 수 있다. 이 캐시는 항상 변수의 실제 값과 동기화되지 않는다. 한 스레드에서 공유 상태를 변경하면 캐시가 업데이트될 때까지 다른 스레드에서는 볼 수 없다.

## @Volatile

- 변수의 변경사항을 다른 스레드에 즉시 표시하기 위해 다음 예제에서 @Voltile 주석을사용할 수 있다.
- 스레드 x가 @Voltile 변수를 수정하면 다른 스레드 y가 즉시 변경사항을 볼 수 있음을 의미한다.
- 휘발성 변수를 이용하여 스레드 안전 카운터 문제를 해결하지는 못한다. → 두 개의 스레드가 변수 값을 간발의 차로 읽어서 그 결과로 일부 변경사항이 유실되기 때문

→ 다른 스레드가 읽거나 수정하는 동안 스레드의 읽기가 발생할 때

→ 다른 스레드가 수정한 후 스레드 읽기가 발생하지만. 스레드의 로컬 캐시가 업데이트디지 않았을 때

—> 휘발성 변수는 상태를 읽을 때 항상 최신 값을 유지함으로써 두 뻔재 경우에는 보호가 가능하지만 첫번째 경우는 보호 기능을 보장하지 않는다.

# @Volatile을 사용하는 경우

- 변수 값의 변경은 현재 상태에 의존하지 않는다. (false→ true , true→ true 이거나 false→false, true→false와 같은 경우)
- 휘발성 변수는 다른 변수에 의존하지 않으며 다른 변수도 휘발성 변수에 의존하지 않는다.

→ 둘 다 만족하는 경우에 사용하면 좋다.

→ 모든 스레드가 변수의 변경을 요청할 수 있으며 모든 스레드가 즉시 볼 수 있다는 것이다.

# 원자적 데이터 구조

- AtomicInteger 등.. → 공유 상태가 복잡하며 확장이 잘 되지 않는 경향이 있다.