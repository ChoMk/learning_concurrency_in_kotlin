# 일시 중단 가능한 시퀀스 및 이터레이터

- 호출 사이에서 일시 중단되지만, 실행 중에는 일시 중단될 수 없다. 이로 인해 일시 중단 연산이 없어도 반복할 수 있다.
- 시퀀스와 이터레이터의 빌더는 CorutineContext를 받지 않는다.  기본적으로 코드를 호출한 컨택스트와 동일한 컨택스트에서 코드가 실행됨을 의미한다.
- 정보 산출 후에만 일시 중지할 수 있다. 이를 위해서는 yield() 또는 yieldAll() 함수를 호출해야 한다.

# 이터레이터

- 인덱스로 요소를 검색할 수 없으므로 요소는 순서대로만 액세스할 수 있다.
- 더 많은 요소가 있는지 여부를 나타내는 hasNext() 함수가 있다.
- 요소는 한 방향으로만 검색할 수 있다. 이전 요서를 검색할 방법은 없다.
- 재설정할 수 없으므로 한 번만 반복할 수 있다.

### hasNext()의 내부 작업에 대한 참고

- hasNext()가 작동하려면 런타임은 코루틴 실행을 재개한다. 새로운 값이 나오면 함수는 true를 반환하고, 더 이상 값이 없어 이터레이터의 실행이 끝나면 함수는 false를 반환한다.
- hasNext 호출하면 이때서야 next에 들어갈 값을 만든다.

# 시퀀스

- 인덱스로 값을 가져올 수 있다.
- 상태가 저장되지 않으며, 상호 작용한 후 자동으로 재설정 된다.
- 한 번의 호출로 값 그룹을 가져올 수 있다.

## 시퀀스는 상태가 없다. : 이터레이터를 사용하는 것과 달리 시퀀스는 각각의 호출마다 요소의 처음부터 실행 됨을 알 수 있다.

# 프로듀서

- 시퀀스와 이터레이터에는 실행 중에 일시 중단할 수 없다는 제한이 있다. 이상적으로 다른 작업이 끝나기를 기다리는 동안 일시 중단할 수 있어야 해서 이것은 대부분 큰 제약사항이다.
- 프로듀서는 값이 생성된 후 일시 중단되며, 새로운 값이 요청될 때 다시 재개된다. 이는 일시 중단 시퀀스 및 이터레이터와 유사
- 프로듀서는 특정 CoroutineContext로 생성할 수 있다.
- 전달되는 일시 중단 람다의 본문은 언제든지 일시 중단될 수 있다.
- 어느 시점에서든 일시 중단할 수 있으므로 프로듀서의 값은 일시 중단 연산에서만 수신할 수 있다.
- 채널을 사용해 작동하므로 데이터를 스트림처럼 생각할 수 있다. 요소를 수신하면 스트림에서 요소가 제거된다.