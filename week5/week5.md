- 실 사례를 통한 채널의 이해
- 채널의 유형들
- 채널과의 상호 작용
- RSS리더를 위한 실제 채널 구현

# 채널의 이해

- 각 인덱서가 응답을 반환하는 시간이 다르고 일부는 상당히 오래 걸릴 수 있다는 문제점이 있다. 그렇게 때문에 모든 코루틴이 완료될 때까지 기다려야 하는데, 결과 표시를 지연시켜서 사용자가 즉시 결과와 상호작용하는 것을 방해한다. → Channel<ResultDto>를 반환하는 것으로 결과가 수신되는 즉시 ui로 보낼 수 있다. 가장 좋은 선택은 ReceiveChannel<ResultDto>를 사용하는 것이다. 둘째는 search()에서 결과가 도착하는 대로 코루틴으로부터 끊김 없이 결과를 수신할 수 있도록 하는 방법이다.
- 이를 위해 각 코루틴은 응답을 가져오고 처리할 때 단일 채널을 통해서 결과를 전송한다.

# 분산 작업 사례

- 데이터 fetch와 파싱 및 저장을 하나의 코루틴에서 처리하면 커넥션(fetch)을 사용하지 않게 된다. fetch 부분과 파싱 및 저장의 로직을 서로 다른 코루틴으로 분리하고 이를 채널을 통하여 전달하는 방식으로 구성하면 커넥션 사용률을 높일 수 있다.

# 채널 유형과 배압

- 배압을 구성하기 위해 채널에 대한 버퍼를 정의할 수 있다. 채널을 통해 데이터를 보내는 코루틴은 채널 안의 요소가 버퍼 크기에 도달하면 일시 중단된다. 채널에서 요소가 제거되는 즉시, 송신자는 다시 재개된다.

## 언버퍼드 채널 - 버퍼가 없는 채널을 언버퍼드 채널이라고 한다.

- Channel() 함수는 두 가지 구현을 갖고 있는데 하나는 버퍼 용량을 파라미터로 갖고, 다른 하나는 아무런 파라미터도 갖지 않는다. 파라미터 없이 함수를 호출해서 RenderzvousChannel(언버퍼드)을 얻을 수 있다.
- send가 발생하기 전에 일시 정지한다.

## 버퍼드 채널

- LinkedListChannel 무한한 채널이다.
- ArrayChannel 이 채널 유형은 버퍼 크기를 0부터 최대 int.max -1까지
- ConflatedChannel 내보내 요소가 유실돼도 괜찮다는 생각이 깔려 있을 때 사용.

# 채널과 상호작용

## sendChannel

채널을 통해 요소를 보내기 위한 몇 개의 함수와 무언가를 보낼 수 있는지 검증하기 위한 다른 함수들을 정의한다.

offer() 함수는 대기열에 추가할 요소를 가지며, 채널의 상태에 따라 boolean을 반환하거나 예외를 던진다.

## Receivechannel

isCloseForReceive, isEmpty를 통하여 상태를 체크하여 받을 수 있다.